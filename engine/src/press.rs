//! Structured press (diplomacy) support.
//!
//! Handles parsing inbound press commands, storing received press messages,
//! tracking per-power trust scores, and generating outbound press.

use crate::board::province::Power;

/// Message types for structured press.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PressType {
    RequestSupport { from_prov: String, to_prov: String },
    ProposeNonaggression { provinces: Vec<String> },
    ProposeAlliance { against: Option<Power> },
    Threaten { province: String },
    OfferDeal { i_take: String, you_take: String },
    Accept,
    Reject,
}

/// A structured press message received from another power.
#[derive(Debug, Clone)]
pub struct PressMessage {
    pub from: Power,
    pub press_type: PressType,
    pub turn_received: u16,
}

/// Outbound press message generated by the engine.
#[derive(Debug, Clone)]
pub struct PressOut {
    pub to: Power,
    pub press_type: PressType,
}

/// Per-power trust model.
///
/// Tracks trust scores based on whether powers follow through on
/// diplomatic commitments. Trust decays over time and increases
/// with fulfilled agreements.
#[derive(Debug, Clone)]
pub struct TrustModel {
    /// Per-power trust score in [0.0, 1.0]. 0.5 = neutral.
    pub scores: [f64; 7],
    /// Pending commitments: (power_index, press_type_tag, turn_made)
    pending: Vec<(usize, CommitmentTag, u16)>,
}

/// Tags for tracking commitments.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[allow(dead_code)]
enum CommitmentTag {
    Nonaggression,
    Alliance,
    SupportRequest,
}

/// Default trust score for all powers.
const DEFAULT_TRUST: f64 = 0.5;

/// Trust increase when a commitment is fulfilled.
const TRUST_FULFILL_BONUS: f64 = 0.08;

/// Trust decrease when a commitment is broken.
const TRUST_BREAK_PENALTY: f64 = 0.12;

/// Per-turn trust decay rate (trust drifts toward 0.5).
const TRUST_DECAY_RATE: f64 = 0.02;

impl TrustModel {
    /// Creates a new trust model with neutral trust for all powers.
    pub fn new() -> Self {
        TrustModel {
            scores: [DEFAULT_TRUST; 7],
            pending: Vec::new(),
        }
    }

    /// Returns the trust score for a power.
    pub fn trust(&self, power: Power) -> f64 {
        self.scores[power as usize]
    }

    /// Records a commitment from a power (e.g., they proposed nonaggression).
    fn record_commitment(&mut self, power: Power, tag: CommitmentTag, turn: u16) {
        self.pending.push((power as usize, tag, turn));
    }

    /// Updates trust when a power fulfills a commitment.
    pub fn fulfill(&mut self, power: Power) {
        let idx = power as usize;
        self.scores[idx] = (self.scores[idx] + TRUST_FULFILL_BONUS).min(1.0);
    }

    /// Updates trust when a power breaks a commitment.
    pub fn betray(&mut self, power: Power) {
        let idx = power as usize;
        self.scores[idx] = (self.scores[idx] - TRUST_BREAK_PENALTY).max(0.0);
    }

    /// Applies per-turn decay: trust drifts toward the neutral value (0.5).
    pub fn decay(&mut self) {
        for score in &mut self.scores {
            if *score > DEFAULT_TRUST {
                *score = (*score - TRUST_DECAY_RATE).max(DEFAULT_TRUST);
            } else if *score < DEFAULT_TRUST {
                *score = (*score + TRUST_DECAY_RATE).min(DEFAULT_TRUST);
            }
        }
    }

    /// Resets all trust to neutral.
    pub fn reset(&mut self) {
        self.scores = [DEFAULT_TRUST; 7];
        self.pending.clear();
    }
}

/// Press state stored in the engine between commands.
#[derive(Debug, Clone)]
pub struct PressState {
    /// Messages received this turn (cleared on newgame or new position).
    pub received: Vec<PressMessage>,
    /// Trust model persists across turns.
    pub trust: TrustModel,
    /// Outbound press generated during search.
    pub outbound: Vec<PressOut>,
    /// Current turn (year) for tracking commitment age.
    pub current_turn: u16,
}

impl PressState {
    pub fn new() -> Self {
        PressState {
            received: Vec::new(),
            trust: TrustModel::new(),
            outbound: Vec::new(),
            current_turn: 1901,
        }
    }

    /// Clears per-turn state but preserves trust model.
    pub fn clear_turn(&mut self) {
        self.received.clear();
        self.outbound.clear();
    }

    /// Full reset for a new game.
    pub fn reset(&mut self) {
        self.received.clear();
        self.outbound.clear();
        self.trust.reset();
        self.current_turn = 1901;
    }

    /// Adds a received press message.
    pub fn receive(&mut self, msg: PressMessage) {
        // Update trust based on message type
        match &msg.press_type {
            PressType::ProposeNonaggression { .. } | PressType::ProposeAlliance { .. } => {
                self.trust.record_commitment(
                    msg.from,
                    CommitmentTag::Nonaggression,
                    self.current_turn,
                );
            }
            PressType::Accept => {
                // Accepting a proposal slightly increases trust
                let idx = msg.from as usize;
                self.trust.scores[idx] =
                    (self.trust.scores[idx] + TRUST_FULFILL_BONUS * 0.5).min(1.0);
            }
            PressType::Threaten { .. } => {
                // Threats decrease trust
                let idx = msg.from as usize;
                self.trust.scores[idx] =
                    (self.trust.scores[idx] - TRUST_BREAK_PENALTY * 0.5).max(0.0);
            }
            _ => {}
        }
        self.received.push(msg);
    }
}

/// Parses the raw text after "press " into a structured PressMessage.
///
/// Format: `<from_power> <message_type> [args...]`
///
/// Examples:
/// - `france propose_alliance against germany`
/// - `russia request_support war gal`
/// - `england accept`
pub fn parse_press_raw(raw: &str) -> Option<PressMessage> {
    let tokens: Vec<&str> = raw.split_whitespace().collect();
    if tokens.len() < 2 {
        return None;
    }

    let from = Power::from_name(tokens[0])?;
    let press_type = match tokens[1] {
        "request_support" => {
            if tokens.len() < 4 {
                return None;
            }
            PressType::RequestSupport {
                from_prov: tokens[2].to_string(),
                to_prov: tokens[3].to_string(),
            }
        }
        "propose_nonaggression" => {
            let provinces: Vec<String> = tokens[2..].iter().map(|s| s.to_string()).collect();
            PressType::ProposeNonaggression { provinces }
        }
        "propose_alliance" => {
            let against = if tokens.len() >= 4 && tokens[2] == "against" {
                Power::from_name(tokens[3])
            } else {
                None
            };
            PressType::ProposeAlliance { against }
        }
        "threaten" => {
            if tokens.len() < 3 {
                return None;
            }
            PressType::Threaten {
                province: tokens[2].to_string(),
            }
        }
        "offer_deal" => {
            if tokens.len() < 4 {
                return None;
            }
            PressType::OfferDeal {
                i_take: tokens[2].to_string(),
                you_take: tokens[3].to_string(),
            }
        }
        "accept" => PressType::Accept,
        "reject" => PressType::Reject,
        _ => return None,
    };

    Some(PressMessage {
        from,
        press_type,
        turn_received: 0, // set by caller
    })
}

/// Formats an outbound press message as a DUI protocol line.
///
/// Returns: `press_out <to_power> <message_type> [args...]`
pub fn format_press_out(press: &PressOut) -> String {
    let to = press.to.name();
    match &press.press_type {
        PressType::RequestSupport { from_prov, to_prov } => {
            format!("press_out {} request_support {} {}", to, from_prov, to_prov)
        }
        PressType::ProposeNonaggression { provinces } => {
            if provinces.is_empty() {
                format!("press_out {} propose_nonaggression", to)
            } else {
                format!(
                    "press_out {} propose_nonaggression {}",
                    to,
                    provinces.join(" ")
                )
            }
        }
        PressType::ProposeAlliance { against } => match against {
            Some(p) => format!("press_out {} propose_alliance against {}", to, p.name()),
            None => format!("press_out {} propose_alliance", to),
        },
        PressType::Threaten { province } => {
            format!("press_out {} threaten {}", to, province)
        }
        PressType::OfferDeal { i_take, you_take } => {
            format!("press_out {} offer_deal {} {}", to, i_take, you_take)
        }
        PressType::Accept => format!("press_out {} accept", to),
        PressType::Reject => format!("press_out {} reject", to),
    }
}

/// Computes a trust-based adjustment to the cooperation penalty.
///
/// Allied powers (high trust from proposals/acceptance) get a negative
/// adjustment (reducing the penalty for attacking others, i.e., encouraging
/// cooperation with the ally). Hostile powers (low trust from threats)
/// get a positive adjustment (increasing willingness to attack them).
///
/// Returns a per-power modifier: positive = more willing to attack,
/// negative = less willing to attack (cooperate).
pub fn trust_cooperation_adjustments(trust: &TrustModel, our_power: Power) -> [f64; 7] {
    let mut adjustments = [0.0f64; 7];
    for (i, &score) in trust.scores.iter().enumerate() {
        if i == our_power as usize {
            continue;
        }
        // Trust > 0.5 means allied: reduce willingness to attack (negative adjustment)
        // Trust < 0.5 means hostile: increase willingness to attack (positive adjustment)
        adjustments[i] = (DEFAULT_TRUST - score) * 4.0;
    }
    adjustments
}

/// Generates outbound press based on the engine's planned orders.
///
/// Looks at what the engine plans to do and generates contextually
/// appropriate press messages (e.g., request support for planned moves,
/// propose nonaggression with non-adjacent powers).
pub fn generate_outbound_press(
    our_power: Power,
    planned_orders: &[crate::board::Order],
    state: &crate::board::state::BoardState,
    trust: &TrustModel,
) -> Vec<PressOut> {
    use crate::board::province::{ALL_POWERS, PROVINCE_COUNT};
    use crate::board::Order;

    let mut outbound = Vec::new();

    // Find powers we're attacking
    let mut attacking: [bool; 7] = [false; 7];
    for order in planned_orders {
        if let Order::Move { dest, .. } = order {
            let dst = dest.province;
            if let Some(owner) = state.sc_owner[dst as usize] {
                if owner != our_power {
                    attacking[owner as usize] = true;
                }
            }
            if let Some((p, _)) = state.units[dst as usize] {
                if p != our_power {
                    attacking[p as usize] = true;
                }
            }
        }
    }

    // Find neighboring powers (powers with units adjacent to our units)
    let mut neighboring: [bool; 7] = [false; 7];
    for i in 0..PROVINCE_COUNT {
        if let Some((p, _)) = state.units[i] {
            if p == our_power {
                for adj in
                    crate::board::adjacency::adj_from(crate::board::province::ALL_PROVINCES[i])
                {
                    if let Some((adj_p, _)) = state.units[adj.to as usize] {
                        if adj_p != our_power {
                            neighboring[adj_p as usize] = true;
                        }
                    }
                }
            }
        }
    }

    for &power in ALL_POWERS.iter() {
        if power == our_power {
            continue;
        }
        let pi = power as usize;
        let power_trust = trust.trust(power);

        if !attacking[pi] && neighboring[pi] && power_trust >= 0.4 {
            // Not attacking a neighbor with decent trust: propose nonaggression
            outbound.push(PressOut {
                to: power,
                press_type: PressType::ProposeNonaggression {
                    provinces: Vec::new(),
                },
            });
        }
    }

    // Request support for supported moves
    for order in planned_orders {
        if let Order::SupportMove {
            supported, dest, ..
        } = order
        {
            let supported_prov = supported.location.province;
            // Check if the supported unit belongs to another power
            if let Some((unit_power, _)) = state.units[supported_prov as usize] {
                if unit_power != our_power {
                    outbound.push(PressOut {
                        to: unit_power,
                        press_type: PressType::RequestSupport {
                            from_prov: supported_prov.name().to_string(),
                            to_prov: dest.province.name().to_string(),
                        },
                    });
                }
            }
        }
    }

    // Limit outbound to avoid spam (max 3 messages per turn)
    outbound.truncate(3);
    outbound
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_press_request_support() {
        let msg = parse_press_raw("russia request_support war gal").unwrap();
        assert_eq!(msg.from, Power::Russia);
        assert_eq!(
            msg.press_type,
            PressType::RequestSupport {
                from_prov: "war".to_string(),
                to_prov: "gal".to_string(),
            }
        );
    }

    #[test]
    fn parse_press_propose_alliance() {
        let msg = parse_press_raw("france propose_alliance against germany").unwrap();
        assert_eq!(msg.from, Power::France);
        assert_eq!(
            msg.press_type,
            PressType::ProposeAlliance {
                against: Some(Power::Germany),
            }
        );
    }

    #[test]
    fn parse_press_propose_alliance_no_target() {
        let msg = parse_press_raw("france propose_alliance").unwrap();
        assert_eq!(msg.press_type, PressType::ProposeAlliance { against: None });
    }

    #[test]
    fn parse_press_propose_nonaggression() {
        let msg = parse_press_raw("england propose_nonaggression nwy swe").unwrap();
        assert_eq!(msg.from, Power::England);
        assert_eq!(
            msg.press_type,
            PressType::ProposeNonaggression {
                provinces: vec!["nwy".to_string(), "swe".to_string()],
            }
        );
    }

    #[test]
    fn parse_press_threaten() {
        let msg = parse_press_raw("turkey threaten gre").unwrap();
        assert_eq!(msg.from, Power::Turkey);
        assert_eq!(
            msg.press_type,
            PressType::Threaten {
                province: "gre".to_string(),
            }
        );
    }

    #[test]
    fn parse_press_offer_deal() {
        let msg = parse_press_raw("italy offer_deal tun gre").unwrap();
        assert_eq!(msg.from, Power::Italy);
        assert_eq!(
            msg.press_type,
            PressType::OfferDeal {
                i_take: "tun".to_string(),
                you_take: "gre".to_string(),
            }
        );
    }

    #[test]
    fn parse_press_accept() {
        let msg = parse_press_raw("france accept").unwrap();
        assert_eq!(msg.press_type, PressType::Accept);
    }

    #[test]
    fn parse_press_reject() {
        let msg = parse_press_raw("russia reject").unwrap();
        assert_eq!(msg.press_type, PressType::Reject);
    }

    #[test]
    fn parse_press_invalid_power() {
        assert!(parse_press_raw("narnia accept").is_none());
    }

    #[test]
    fn parse_press_too_short() {
        assert!(parse_press_raw("france").is_none());
        assert!(parse_press_raw("").is_none());
    }

    #[test]
    fn parse_press_unknown_type() {
        assert!(parse_press_raw("france yell_loudly").is_none());
    }

    #[test]
    fn format_press_out_request_support() {
        let press = PressOut {
            to: Power::France,
            press_type: PressType::RequestSupport {
                from_prov: "war".to_string(),
                to_prov: "gal".to_string(),
            },
        };
        assert_eq!(
            format_press_out(&press),
            "press_out france request_support war gal"
        );
    }

    #[test]
    fn format_press_out_propose_alliance() {
        let press = PressOut {
            to: Power::Russia,
            press_type: PressType::ProposeAlliance {
                against: Some(Power::Turkey),
            },
        };
        assert_eq!(
            format_press_out(&press),
            "press_out russia propose_alliance against turkey"
        );
    }

    #[test]
    fn format_press_out_accept() {
        let press = PressOut {
            to: Power::England,
            press_type: PressType::Accept,
        };
        assert_eq!(format_press_out(&press), "press_out england accept");
    }

    #[test]
    fn trust_model_initial_neutral() {
        let trust = TrustModel::new();
        for &p in &crate::board::province::ALL_POWERS {
            assert!((trust.trust(p) - 0.5).abs() < 0.001);
        }
    }

    #[test]
    fn trust_model_fulfill_increases() {
        let mut trust = TrustModel::new();
        let before = trust.trust(Power::France);
        trust.fulfill(Power::France);
        assert!(trust.trust(Power::France) > before);
    }

    #[test]
    fn trust_model_betray_decreases() {
        let mut trust = TrustModel::new();
        let before = trust.trust(Power::France);
        trust.betray(Power::France);
        assert!(trust.trust(Power::France) < before);
    }

    #[test]
    fn trust_model_capped_at_bounds() {
        let mut trust = TrustModel::new();
        for _ in 0..100 {
            trust.fulfill(Power::Austria);
        }
        assert!(trust.trust(Power::Austria) <= 1.0);

        for _ in 0..100 {
            trust.betray(Power::England);
        }
        assert!(trust.trust(Power::England) >= 0.0);
    }

    #[test]
    fn trust_model_decay_toward_neutral() {
        let mut trust = TrustModel::new();
        trust.fulfill(Power::France);
        trust.fulfill(Power::France);
        let high = trust.trust(Power::France);
        trust.decay();
        assert!(trust.trust(Power::France) < high);
        assert!(trust.trust(Power::France) >= DEFAULT_TRUST);
    }

    #[test]
    fn trust_model_reset() {
        let mut trust = TrustModel::new();
        trust.fulfill(Power::France);
        trust.betray(Power::Germany);
        trust.reset();
        for &p in &crate::board::province::ALL_POWERS {
            assert!((trust.trust(p) - 0.5).abs() < 0.001);
        }
    }

    #[test]
    fn press_state_receive_updates_trust() {
        let mut ps = PressState::new();
        let before = ps.trust.trust(Power::France);

        ps.receive(PressMessage {
            from: Power::France,
            press_type: PressType::Threaten {
                province: "bre".to_string(),
            },
            turn_received: 1901,
        });

        assert!(ps.trust.trust(Power::France) < before);
        assert_eq!(ps.received.len(), 1);
    }

    #[test]
    fn press_state_clear_turn_preserves_trust() {
        let mut ps = PressState::new();
        ps.trust.fulfill(Power::France);
        let trust_before = ps.trust.trust(Power::France);

        ps.receive(PressMessage {
            from: Power::Russia,
            press_type: PressType::Accept,
            turn_received: 1901,
        });

        ps.clear_turn();
        assert!(ps.received.is_empty());
        assert!((ps.trust.trust(Power::France) - trust_before).abs() < 0.001);
    }

    #[test]
    fn trust_cooperation_adjustments_neutral() {
        let trust = TrustModel::new();
        let adj = trust_cooperation_adjustments(&trust, Power::Austria);
        // All neutral trust -> all adjustments near 0
        for &a in &adj {
            assert!(a.abs() < 0.001);
        }
    }

    #[test]
    fn trust_cooperation_adjustments_ally() {
        let mut trust = TrustModel::new();
        trust.fulfill(Power::France);
        trust.fulfill(Power::France);
        let adj = trust_cooperation_adjustments(&trust, Power::Austria);
        // France has high trust -> negative adjustment (less willing to attack)
        assert!(adj[Power::France as usize] < 0.0);
    }

    #[test]
    fn trust_cooperation_adjustments_hostile() {
        let mut trust = TrustModel::new();
        trust.betray(Power::Turkey);
        trust.betray(Power::Turkey);
        let adj = trust_cooperation_adjustments(&trust, Power::Austria);
        // Turkey has low trust -> positive adjustment (more willing to attack)
        assert!(adj[Power::Turkey as usize] > 0.0);
    }

    #[test]
    fn round_trip_press_request_support() {
        let raw = "france request_support par bur";
        let msg = parse_press_raw(raw).unwrap();
        let out = PressOut {
            to: Power::Russia,
            press_type: msg.press_type,
        };
        let formatted = format_press_out(&out);
        assert_eq!(formatted, "press_out russia request_support par bur");
    }

    #[test]
    fn round_trip_press_propose_nonaggression_empty() {
        let raw = "england propose_nonaggression";
        let msg = parse_press_raw(raw).unwrap();
        let out = PressOut {
            to: Power::France,
            press_type: msg.press_type,
        };
        let formatted = format_press_out(&out);
        assert_eq!(formatted, "press_out france propose_nonaggression");
    }
}
